<style>
:root { --content-max-width: 90%; }
body { font-size: 4rem; }
.segment_container { display: flex; flex-direction: row; }
.segment { margin-left: 2%; margin-right: 2%; flex: 1; }
</style>
<div class="segment_container">
<div class="segment">

<!--slider split-->

To save you the trouble of figuring this out:

- `clock` Does not account for time when the process is blocked. {{footnote: More accurately, it ["returns the approximate processor time used by the process since the beginning of an implementation-defined era related to the program's execution"](https://en.cppreference.com/w/c/chrono/clock)}}
- `time`{{footnote: both C and UNIX}} only measures on the resolution of seconds in most implementations, which isn't precise enough for our purposes
- `utc/tai/gps/file_clock` are application-specific and require C++20

</div>
<div class="segment">

<!--slider cell-split-->

Of the remaining functions:
- `gettimeofday` and `clock_gettime` are alright, albeit platform dependent.
- `system_clock` and `high_resolution_clock` are likely fine, but can exhibit bad behavior on rare occasions. {{footnote: If the program is running on a weird computer, or during a leap day/second, or during daylight savings transitions, the time reported by these functions may go backwards. This should not matter for personal/class projects, but would not be suitable for measuring duration in real production environments.}}
- `steady_clock` is perhaps the most "correct" tool to use, but - like the rest of the C++ clock classes - it's a little fiddly to work with
</div>
</div>
<div class="segment_container">
<div class="segment">

<!--slider row-split-->


</div>
</div>
